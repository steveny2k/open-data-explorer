open-data-explorer
===================

The very quick getting started guide

1. Git clone
2. cd into directory
3. npm install
4. npm start
5. http://localhost:8000

## Code Structure

The code structure reflects a [redux pattern for managing state in a javascript application](http://redux.js.org/).

### actions

### components - components are similar to views in that they define the rendering of the app. These components are tied to root containers, which define the application logic.

### constants - app constants as needed, things like API roots, etc.

### containers - containers are a special kind of component. Some people call these smart components, skinny components, controller components. Whatever you call them, they basically define the application logic and pass actions and state down to the components.

### middleware - this is where all of the specific functions related to external API calls (e.g. Socrata) live.

### reducers - per the redux approach, reducers change the state based on actions. All state change logic lives in reducers.

### scss - styles

### store - the store holds the whole state tree of the application. A store is not a class; it's just an object with a few methods on it.

### app.jsx - the entry point for the application

### routes.jsx -


## Contributing

### Zenhub

We use Zenhub to organize the work. Interested in following along or contributing, make sure to install [Zenhub](https://www.zenhub.io) so you can see our boards.

### Issue management

We've adopted a similar [standardization of labels](https://github.com/datasf/data-portal-exploration/labels) as described here to make issues simpler to reason about:

https://robinpowered.com/blog/best-practice-system-for-organizing-and-tagging-github-issues/

In addition we kept the `help wanted` label to indicate good places for others to dig in. There's also an `Epic` label which is generated by Zenhub to define Epics. [Learn what Epics are on the Zenhub blog](https://www.zenhub.io/blog/working-with-epics-in-github/).


### Branch naming format

We use Git Flow for branch naming, which follows the format

`<type>/<branch name>`

The following are the **types** we use:

- release/: For official releases
- hotfix/: for making fixes off a previous release
- bugfix/: for making fixes for a current bug
- feature/: for adding features to the system
- docs/: for making changes/updates to documentation

